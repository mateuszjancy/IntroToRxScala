<pre>
███████╗ ██████╗ █████╗ ██╗      █████╗
██╔════╝██╔════╝██╔══██╗██║     ██╔══██╗
███████╗██║     ███████║██║     ███████║
╚════██║██║     ██╔══██║██║     ██╔══██║
███████║╚██████╗██║  ██║███████╗██║  ██║
╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝

██╗   ██╗███████╗███████╗██████╗
██║   ██║██╔════╝██╔════╝██╔══██╗
██║   ██║███████╗█████╗  ██████╔╝
██║   ██║╚════██║██╔══╝  ██╔══██╗
╚██████╔╝███████║███████╗██║  ██║
 ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝

 ██████╗ ██████╗  ██████╗ ██╗   ██╗██████╗
██╔════╝ ██╔══██╗██╔═══██╗██║   ██║██╔══██╗
██║  ███╗██████╔╝██║   ██║██║   ██║██████╔╝
██║   ██║██╔══██╗██║   ██║██║   ██║██╔═══╝
╚██████╔╝██║  ██║╚██████╔╝╚██████╔╝██║
 ╚═════╝ ╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚═╝
</pre>
---
<pre>
        GGGGGGGGGGGGGFFFFFFFFFFFFFFFFFFFFFFTTTTTTTTTTTTTTTTTTTTTTT
     GGG::::::::::::GF::::::::::::::::::::FT:::::::::::::::::::::T
   GG:::::::::::::::GF::::::::::::::::::::FT:::::::::::::::::::::T
  G:::::GGGGGGGG::::GFF::::::FFFFFFFFF::::FT:::::TT:::::::TT:::::T
 G:::::G       GGGGGG  F:::::F       FFFFFFTTTTTT  T:::::T  TTTTTT
G:::::G                F:::::F                     T:::::T
G:::::G                F::::::FFFFFFFFFF           T:::::T
G:::::G    GGGGGGGGGG  F:::::::::::::::F           T:::::T
G:::::G    G::::::::G  F:::::::::::::::F           T:::::T
G:::::G    GGGGG::::G  F::::::FFFFFFFFFF           T:::::T
G:::::G        G::::G  F:::::F                     T:::::T
 G:::::G       G::::G  F:::::F                     T:::::T
  G:::::GGGGGGGG::::GFF:::::::FF                 TT:::::::TT
   GG:::::::::::::::GF::::::::FF                 T:::::::::T
     GGG::::::GGG:::GF::::::::FF                 T:::::::::T
        GGGGGG   GGGGFFFFFFFFFFF                 TTTTTTTTTTT
</pre>
---
<pre>
██████╗  █████╗ ██████╗ ████████╗ ██████╗ ███████╗███████╗
██╔══██╗██╔══██╗██╔══██╗╚══██╔══╝██╔═══██╗██╔════╝╚══███╔╝
██████╔╝███████║██████╔╝   ██║   ██║   ██║███████╗  ███╔╝
██╔══██╗██╔══██║██╔══██╗   ██║   ██║   ██║╚════██║ ███╔╝
██████╔╝██║  ██║██║  ██║   ██║   ╚██████╔╝███████║███████╗
╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚══════╝╚══════╝

███╗   ███╗██╗██╗  ██╗██╗   ██╗██╗     ███████╗██╗  ██╗██╗
████╗ ████║██║██║ ██╔╝██║   ██║██║     ██╔════╝██║ ██╔╝██║
██╔████╔██║██║█████╔╝ ██║   ██║██║     ███████╗█████╔╝ ██║
██║╚██╔╝██║██║██╔═██╗ ██║   ██║██║     ╚════██║██╔═██╗ ██║
██║ ╚═╝ ██║██║██║  ██╗╚██████╔╝███████╗███████║██║  ██╗██║
╚═╝     ╚═╝╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚═╝
</pre>
---
<pre>
███╗   ███╗ █████╗ ████████╗███████╗██╗   ██╗███████╗███████╗
████╗ ████║██╔══██╗╚══██╔══╝██╔════╝██║   ██║██╔════╝╚══███╔╝
██╔████╔██║███████║   ██║   █████╗  ██║   ██║███████╗  ███╔╝
██║╚██╔╝██║██╔══██║   ██║   ██╔══╝  ██║   ██║╚════██║ ███╔╝
██║ ╚═╝ ██║██║  ██║   ██║   ███████╗╚██████╔╝███████║███████╗
╚═╝     ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝ ╚═════╝ ╚══════╝╚══════╝

     ██╗ █████╗ ███╗   ██╗ ██████╗██╗   ██╗
     ██║██╔══██╗████╗  ██║██╔════╝╚██╗ ██╔╝
     ██║███████║██╔██╗ ██║██║      ╚████╔╝
██   ██║██╔══██║██║╚██╗██║██║       ╚██╔╝
╚█████╔╝██║  ██║██║ ╚████║╚██████╗   ██║
</pre>
---
###Agenda###
1. Concept
2. Building blocks
3. Exceptions
4. Subscription
5. Hot or cold
6. Nested
7. Scheduler
8. Subject
---
###Imports###

```scala
import java.util.concurrent.{CopyOnWriteArrayList, CountDownLatch}
import java.util.concurrent.{Executors, ScheduledFuture, TimeUnit}
import java.util.concurrent.atomic.AtomicInteger

import rx.lang.scala.schedulers.ComputationScheduler
import rx.lang.scala.{Observable, Observer, Subject, Subscription}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.concurrent.duration._
import scala.util.Random
```
---
###Delay function###

```scala
def delay(d: Long)(block: => Unit) = {
  val e = Executors.newScheduledThreadPool(1)
  val r = new Runnable { override def run(): Unit = block }
  e.schedule(r, d, TimeUnit.SECONDS)
  e.shutdown()
}
```
---
<pre>
██████╗ ███████╗ █████╗  ██████╗████████╗██╗██╗   ██╗███████╗██╗  ██╗
██╔══██╗██╔════╝██╔══██╗██╔════╝╚══██╔══╝██║██║   ██║██╔════╝╚██╗██╔╝
██████╔╝█████╗  ███████║██║        ██║   ██║██║   ██║█████╗   ╚███╔╝
██╔══██╗██╔══╝  ██╔══██║██║        ██║   ██║╚██╗ ██╔╝██╔══╝   ██╔██╗
██║  ██║███████╗██║  ██║╚██████╗   ██║   ██║ ╚████╔╝ ███████╗██╔╝ ██╗
╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝
</pre>

"An API for asynchronous programming with observable streams"

"The Observer pattern done right ReactiveX is a combination of the best
ideas from the Observer pattern, the Iterator pattern, and functional
programming.

- Easily **create event streams **or data streams.
- Compose and **transform streams **with query-like operators.
- Subscribe to any observable stream to **perform side effects.**"

---
<pre>
██████╗ ██╗  ██╗███████╗ ██████╗ █████╗ ██╗      █████╗
██╔══██╗╚██╗██╔╝██╔════╝██╔════╝██╔══██╗██║     ██╔══██╗
██████╔╝ ╚███╔╝ ███████╗██║     ███████║██║     ███████║
██╔══██╗ ██╔██╗ ╚════██║██║     ██╔══██║██║     ██╔══██║
██║  ██║██╔╝ ██╗███████║╚██████╗██║  ██║███████╗██║  ██║
╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
</pre>

**Main concept**
- This is a Scala **adapter** to RxJava.
- Is **lightweight**.
- Focused on **single concept**.

**RxScala Basic building blocks**
- Observable
- Observer
- Combinators
---
###How to create Observable?###

```scala
//From sequence of values:
Observable.just(1, 2, 3)

//From Iterable:
Observable.from(List(1, 2, 3))

//From Future:
Observable.from(Future {2 * 2})

//Also we can create a custom Observable:
Observable.create[Int] { o =>
  o.onNext(1); o.onNext(2)
  o.onCompleted()
  Subscription()
}
```
---
###Contract###

**Every Observable can be in one of three states:**
- **Uncompleted**: can emit events
- **Error**: cannot emit events
- **Completed**: cannot emit events

**We can subscribe to Observable by passing Observer:**
- **onNext**: can be called **zero **or more times
- **onComplete, onError**: after call Observable **can't emit **more events

```scala
trait Observer[-T] {
 def onNext(value: T): Unit = {}
 def onError(error: Throwable): Unit= {}
 def onCompleted(): Unit = {}
}
```

You can always use one of **overloaded subscribe functions**:

```scala
subscribe(
  onNext: T => Unit,
  onError: Throwable => Unit,
  onCompleted: () => Unit): Subscription
```

---
###Contract example.###

We will use those basic functions in examples

```scala
def log[T](msg: T):Unit=println(s"${Thread.currentThread().getName}: $msg")
def error(ex: Throwable): Unit = log(ex.getMessage)
def next[T](name: String)(x: T): Unit= log(s"$name -> $x")
def complete(): Unit = log("Complete")
```
---
<pre>
███████╗██╗  ██╗
██╔════╝╚██╗██╔╝
█████╗   ╚███╔╝
██╔══╝   ██╔██╗
███████╗██╔╝ ██╗
╚══════╝╚═╝  ╚═╝
</pre>

When an Observable object **produces an exception**, it enters the error state
and **cannot emit more events** (it's part of RX contract).

```scala
def exceptionsExample = {
  val o = Observable.just(1, 2, 3)
  val e = Observable.error(new Exception("Boom!!"))
  val j = Observable.just(4, 5, 6)
  val r = o ++ e ++ j

  r.subscribe(next("A"), error)
}
```
---
<pre>
███████╗██╗   ██╗██████╗
██╔════╝██║   ██║██╔══██╗
███████╗██║   ██║██████╔╝
╚════██║██║   ██║██╔══██╗
███████║╚██████╔╝██████╔╝
╚══════╝ ╚═════╝ ╚═════╝

    ███████╗ ██████╗██████╗ ██╗
    ██╔════╝██╔════╝██╔══██╗██║
    ███████╗██║     ██████╔╝██║
    ╚════██║██║     ██╔══██╗██║
    ███████║╚██████╗██║  ██║██║
    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝

        ██████╗ ████████╗██╗ ██████╗ ███╗   ██╗
        ██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║
        ██████╔╝   ██║   ██║██║   ██║██╔██╗ ██║
        ██╔══██╗   ██║   ██║██║   ██║██║╚██╗██║
        ██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║
        ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝
</pre>
---
###Subscription example.###

**Will be called by subscriber in two cases:**
- Subscriber calls **unsubscribe** method on uncompleted observable.
- Observable switch to **completed** state (by calling onComplete).

```scala
def subscriptionExample = {
  val o = Observable.create[Int]{ o =>
    o.onNext(1); o.onNext(2)
    o.onCompleted()
    Subscription { println("exit") }
  }

  o.subscribe(next("A"), error, complete)
  o.subscribe(next("B"), error, complete)
}
```
---
<pre>
 █████╗ ██████╗ ███████╗    ██╗   ██╗ ██████╗ ██╗   ██╗
██╔══██╗██╔══██╗██╔════╝    ╚██╗ ██╔╝██╔═══██╗██║   ██║
███████║██████╔╝█████╗       ╚████╔╝ ██║   ██║██║   ██║
██╔══██║██╔══██╗██╔══╝        ╚██╔╝  ██║   ██║██║   ██║
██║  ██║██║  ██║███████╗       ██║   ╚██████╔╝╚██████╔╝
╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝       ╚═╝    ╚═════╝  ╚═════╝

 ██████╗ ██████╗ ██╗     ██████╗      ██████╗ ██████╗
██╔════╝██╔═══██╗██║     ██╔══██╗    ██╔═══██╗██╔══██╗
██║     ██║   ██║██║     ██║  ██║    ██║   ██║██████╔╝
██║     ██║   ██║██║     ██║  ██║    ██║   ██║██╔══██╗
╚██████╗╚██████╔╝███████╗██████╔╝    ╚██████╔╝██║  ██║
 ╚═════╝ ╚═════╝ ╚══════╝╚═════╝      ╚═════╝ ╚═╝  ╚═╝

██╗  ██╗ ██████╗ ████████╗
██║  ██║██╔═══██╗╚══██╔══╝
███████║██║   ██║   ██║
██╔══██║██║   ██║   ██║
██║  ██║╚██████╔╝   ██║
╚═╝  ╚═╝ ╚═════╝    ╚═╝
</pre>

---
###Event source for next examples###

```scala
object Source {
  def apply() = new Source
}
class Source {
  import scala.collection.JavaConversions._
  val e = Executors.newScheduledThreadPool(1)
  val acc = new AtomicInteger(0)
  var listeners = new CopyOnWriteArrayList[Observer[Int]]
  val runnable = new Runnable {
    override def run(): Unit = {
      val next = acc.incrementAndGet(); println(s"Next: $next")
      listeners.foreach(_.onNext(next))
    }
  }
  def register(o: Observer[Int]) = listeners.add(o)
  def unregister(o: Observer[Int]) = {
    listeners.remove(o); o.onCompleted()
  }
  def start() = e.scheduleWithFixedDelay(runnable, 1, 1, TimeUnit.SECONDS)
  def stop() = e.shutdownNow()
}
```
---
###Cold observable example###

In cold Observable we need
- **Create event **source per each subscription.
- **Stop event source **in case of unsubscription or completion.

```scala
def coldExample = {
  val obs = Observable.create[Int] { o =>
    log("Subscribe")
    val src = Source(); src.start(); src.register(o)
    Subscription {
      log("Unsubscribe"); src.unregister(o); src.stop()
    }
  }
  delay(2) {
    val a = obs.subscribe(next("A"), error, complete)
    delay(5) { a.unsubscribe() }
  }
  delay(4) {
    val b = obs.subscribe(next("B"), error, complete)
    delay(5) { b.unsubscribe() }
  }
}
```
---
###Hot observable###

In hot observable event
- Event source is **independent** of subscribers.
- In case of unsubscription or completion we need to **unregister **observer
  from source.

```scala
def hotExample = {
  val src = Source(); src.start()
  val obs = Observable.create[Int] { o =>
    src.register(o)
    Subscription { log("Unsubscribe"); src.unregister(o) }
  }
  delay(2) {
    val a = obs.subscribe(next("A"), error, complete)
    delay(5) { a.unsubscribe() }
  }
  delay(4) {
    val b = obs.subscribe(next("B"), error, complete)
    delay(5) { b.unsubscribe() }
  }
  delay(15) { log("Source stop"); src.stop() }
}

```
---
###Observables Composition.###

Observables can be **composed by using various combinators **like filter,map...

**It looks similar to Scala sequence collections.**

```scala
Stream(1, 2, 3, 4)
  .filter(_ % 2 == 0)
  .map(x => s"[$x]")
  .foreach(x => println(x))

Observable.just(1, 2, 3, 4)
  .filter(_ % 2 == 0)
  .map(x => s"[$x]")
  .subscribe(x => println(x))
```
---
###Observables Composition example.###

```scala
def composingExample = {
  Observable
    .just(1, 2, 3, 4)
    .filter(_ % 2 == 0)
    .map(even => s"[$even]")
    .take(2)
    .subscribe(next("B"), error, complete)
}
```
---
<pre>
 ███▄    █ ▓█████   ██████ ▄▄▄█████▓▓█████ ▓█████▄
 ██ ▀█   █ ▓█   ▀ ▒██    ▒ ▓  ██▒ ▓▒▓█   ▀ ▒██▀ ██▌
▓██  ▀█ ██▒▒███   ░ ▓██▄   ▒ ▓██░ ▒░▒███   ░██   █▌
▓██▒  ▐▌██▒▒▓█  ▄   ▒   ██▒░ ▓██▓ ░ ▒▓█  ▄ ░▓█▄   ▌
▒██░   ▓██░░▒████▒▒██████▒▒  ▒██▒ ░ ░▒████▒░▒████▓
░ ▒░   ▒ ▒ ░░ ▒░ ░▒ ▒▓▒ ▒ ░  ▒ ░░   ░░ ▒░ ░ ▒▒▓  ▒
░ ░░   ░ ▒░ ░ ░  ░░ ░▒  ░ ░    ░     ░ ░  ░ ░ ▒  ▒
   ░   ░ ░    ░   ░  ░  ░    ░         ░    ░ ░  ░
         ░    ░  ░      ░              ░  ░   ░
                                            ░
</pre>
Observables can be **nested one into another**. We can **flatten or concat** nested
Observables but it's **more complex** than in Seq because of **timing** of events.

```scala
def nested: Observable[Observable[(Long, Int)]] =
Observable.interval(100.millisecond).map { i =>
  def f = Future {
    val delay = Random.nextInt(1000)
    Thread.sleep(delay);
    (i, delay)
  }
  val f1 = Observable.from(f)
  val f2 = Observable.from(f)

  f1 ++ f2
}
```
---
###Nested observables concat example###

First option to **concat **is by calling concat method. This method will emit
events from nested Observable in the **order in which they were created**.

```scala
def concatExample = {
    val cdl = new CountDownLatch(10)
    val s = nested.concat.subscribe { el =>
        cdl.countDown()
        log(s"Id: ${el._1}, Delay: ${el._2}")
    }
    cdl.await()
    s.unsubscribe()
}
```
---
###Nested observables flatten example###

Another option is to use **flatten**. This method will emit events from nested
Observable in the **order in which they were completed**.

```scala
def flattenExample = {
  val cdl = new CountDownLatch(10)
  val s = nested.flatten.subscribe { el =>
    cdl.countDown()
    log(s"Id: ${el._1}, Delay: ${el._2}")
  }
  cdl.await()
  s.unsubscribe()
}
```

Good to know if that **flatMap** internally is using **flatten**
---
<pre>
███████╗ ██████╗██╗  ██╗███████╗██████╗ ██╗   ██╗██╗     ███████╗██████╗
██╔════╝██╔════╝██║  ██║██╔════╝██╔══██╗██║   ██║██║     ██╔════╝██╔══██╗
███████╗██║     ███████║█████╗  ██║  ██║██║   ██║██║     █████╗  ██████╔╝
╚════██║██║     ██╔══██║██╔══╝  ██║  ██║██║   ██║██║     ██╔══╝  ██╔══██╗
███████║╚██████╗██║  ██║███████╗██████╔╝╚██████╔╝███████╗███████╗██║  ██║
╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═════╝  ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝
</pre>
Is used to **encapsulate** the **choice **of the **thread **on which an **observable**
should emit events.

```scala
def schedulerExample = {
  val l = new CountDownLatch(1)
  val scheduler = ComputationScheduler()
  val numbers = Observable.just(1, 2, 3)
  numbers.subscribe(x => log(s"Subscribe: $x"))
  numbers.subscribeOn(scheduler).subscribe { x =>
    log(s"SubscribeOn: $x");l.countDown()
  }
  l.await()
}
```
---
<pre>
███████╗██╗   ██╗██████╗      ██╗███████╗ ██████╗████████╗
██╔════╝██║   ██║██╔══██╗     ██║██╔════╝██╔════╝╚══██╔══╝
███████╗██║   ██║██████╔╝     ██║█████╗  ██║        ██║
╚════██║██║   ██║██╔══██╗██   ██║██╔══╝  ██║        ██║
███████║╚██████╔╝██████╔╝╚█████╔╝███████╗╚██████╗   ██║
╚══════╝ ╚═════╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝
</pre>
Is simultaneously an Observable and an Observer
- Can subscribe
- Can emit events

**Tip**
It is useful in situations when you need to create an Observables for which
inputs are not available yet
---
| \gSubject example

```scala
def subjectExample = {
  val o = Subject[Int]()
  o.subscribe(x => log(s"Subject:$x"))
  List(1, 2, 3).foreach(it => o.onNext(it))
  Observable.just(4, 5, 6).subscribe(o)
}
```
---
<pre>
  ,ad8888ba,       ,adba,            db
 d8"'    `"8b      8I  I8           d88b
d8'        `8b     "8bdP'          d8'`8b
88          88    ,d8"8b  88      d8'  `8b
88          88  .dP'   Yb,8I     d8YaaaaY8b
Y8,    "88,,8P  8P      888'    d8""""""""8b
 Y8a.    Y88P   8b,   ,dP8b    d8'        `8b
  `"Y8888Y"Y8a  `Y8888P"  Yb  d8'          `8b
</pre>
---
###Links###
Project pages:
* [reactivex](http://reactivex.io/)
* [RxJava](https://github.com/ReactiveX/RxJava/)
* [RxScala](https://github.com/ReactiveX/RxScala)

Book:
* [Learning Concurrent Programming in Scala](http://www.amazon.com/Learning-Concurrent-Programming-Aleksandar-Prokopec/dp/1783281413/)

MSDN:
* [channel9](https://channel9.msdn.com/)

Special Thanks:
marconilanna, creator of: [REPLesent](https://github.com/marconilanna/REPLesent)
and patorjk, creator of Text to ASCII Art Generator [TAAG](http://patorjk.com/software/taag/)

---
<pre>
[... [......[..     [..[..      [..
     [..    [..     [.. [..   [..
     [..    [..     [..  [.. [..
     [..    [...... [..    [..
     [..    [..     [..  [.. [..
     [..    [..     [.. [..   [..
     [..    [..     [..[..      [..

</pre>
